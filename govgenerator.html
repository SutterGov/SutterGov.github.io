<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ”¿åºœç»“æ„å›¾ç”Ÿæˆå™¨-è¨ç‰¹æ•°å‘éƒ¨å¼€å‘</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            margin: 0;
            overflow: hidden;
        }
        #canvas-container {
            background: white;
            border-radius: 16px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            margin: 20px;
            position: relative;
            overflow: auto;
            height: calc(100vh - 200px);
            cursor: grab;
        }
        #canvas-container:active {
            cursor: grabbing;
        }
        canvas {
            display: block;
        }
        .context-menu {
            position: absolute;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            padding: 8px 0;
            min-width: 160px;
            z-index: 1000;
            display: none;
            border: 1px solid #e0e0e0;
        }
        .context-menu-item {
            padding: 10px 16px;
            cursor: pointer;
            transition: background 0.2s;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .context-menu-item:hover {
            background: #f5f5f5;
        }
        .context-menu-item.delete {
            color: #dc2626;
        }
        .context-menu-item.delete:hover {
            background: #fef2f2;
        }
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }
        .modal-content {
            background: white;
            border-radius: 12px;
            padding: 24px;
            min-width: 300px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.3);
        }
        .slider-container {
            display: flex;
            align-items: center;
            gap: 12px;
            background: white;
            padding: 12px 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        input[type="range"] {
            -webkit-appearance: none;
            width: 200px;
            height: 6px;
            background: #e0e0e0;
            border-radius: 3px;
            outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: #764ba2;
            border-radius: 50%;
            cursor: pointer;
        }
        .node-input {
            position: absolute;
            border: 2px solid #764ba2;
            background: white;
            padding: 8px;
            font-size: 14px;
            border-radius: 4px;
            outline: none;
            z-index: 100;
            text-align: center;
            display: none;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        .toolbar {
            background: rgba(255,255,255,0.95);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        .btn-secondary {
            background: #f3f4f6;
            color: #374151;
            padding: 10px 20px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            font-weight: 600;
            transition: background 0.2s;
        }
        .btn-secondary:hover {
            background: #e5e7eb;
        }
        .status-badge {
            display: inline-flex;
            align-items: center;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            background: #e0e7ff;
            color: #764ba2;
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        .tooltip {
            position: absolute;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            z-index: 999;
            display: none;
        }
    </style>
<base target="_blank">
</head>
<body>
    <!-- é¡¶éƒ¨å·¥å…·æ  -->
    <div class="toolbar" style="margin: 20px; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 12px;">
        <div style="display: flex; align-items: center; gap: 16px; flex-wrap: wrap;">
            <h1 style="font-size: 24px; font-weight: bold; color: #1f2937;">ğŸ›ï¸ æ”¿åºœç»“æ„å›¾ç”Ÿæˆå™¨</h1>
            <input type="text" id="chart-title" placeholder="è¾“å…¥ç»“æ„å›¾æ ‡é¢˜" 
                   style="padding: 10px 16px; border: 2px solid #e5e7eb; border-radius: 8px; min-width: 350px; font-size: 14px;">
        </div>
        <div style="display: flex; align-items: center; gap: 12px; flex-wrap: wrap;">
            <div class="slider-container">
                <span style="font-size: 14px; font-weight: 600; color: #4b5563;">ğŸ” ç¼©æ”¾</span>
                <input type="range" id="scale-slider" min="0.3" max="3" step="0.1" value="1">
                <span id="scale-value" style="font-size: 14px; font-weight: 600; color: #764ba2; min-width: 45px;">100%</span>
            </div>
            <button onclick="autoLayout()" class="btn-secondary" title="è‡ªåŠ¨æ’åˆ—æ‰€æœ‰èŠ‚ç‚¹">
                ğŸ”„ è‡ªåŠ¨å¸ƒå±€
            </button>
            <div id="connection-status" class="status-badge" style="display: none;">
                è¿çº¿æ¨¡å¼ï¼šé€‰æ‹©ç¬¬ä¸€ä¸ªèŠ‚ç‚¹
            </div>
            <button onclick="downloadPNG()" class="btn-primary">
                ğŸ’¾ ä¸‹è½½ PNG
            </button>
            <button onclick="clearCanvas()" class="btn-secondary" style="color: #dc2626;">
                ğŸ—‘ï¸ æ¸…ç©º
            </button>
        </div>
    </div>

    <!-- ç”»å¸ƒå®¹å™¨ -->
    <div id="canvas-container">
        <canvas id="main-canvas"></canvas>
        <input type="text" id="node-input" class="node-input" placeholder="è¾“å…¥å•ä½åç§°">
    </div>
    <div id="tooltip" class="tooltip">æ‹–æ‹½ç§»åŠ¨ â€¢ ç‚¹å‡»æ·»åŠ å­èŠ‚ç‚¹/ç¼–è¾‘</div>

    <!-- å³é”®èœå• -->
    <div id="context-menu" class="context-menu">
        <div class="context-menu-item" onclick="startEditText()">
            <span>âœï¸</span> ç¼–è¾‘æ–‡å­—
        </div>
        <div class="context-menu-item" onclick="changeColor()">
            <span>ğŸ¨</span> ä¿®æ”¹é¢œè‰²
        </div>
        <div class="context-menu-item" onclick="addSiblingNode()">
            <span>â•</span> æ·»åŠ åŒçº§å•ä½
        </div>
        <div class="context-menu-item" onclick="startConnection()">
            <span>ğŸ”—</span> æ·»åŠ è¿çº¿
        </div>
        <div class="context-menu-item delete" onclick="deleteNode()">
            <span>ğŸ—‘ï¸</span> åˆ é™¤æ­¤å•ä½
        </div>
    </div>

    <!-- é¢œè‰²é€‰æ‹©å™¨æ¨¡æ€æ¡† -->
    <div id="color-modal" class="modal">
        <div class="modal-content">
            <h3 style="margin: 0 0 16px 0; font-size: 18px;">é€‰æ‹©æ–¹å—é¢œè‰²</h3>
            <div style="display: grid; grid-template-columns: repeat(6, 1fr); gap: 10px; margin-bottom: 20px;">
                <button onclick="applyColor('#FFE4E1')" style="width: 40px; height: 40px; background: #FFE4E1; border: 2px solid #ddd; border-radius: 6px; cursor: pointer;"></button>
                <button onclick="applyColor('#FFD700')" style="width: 40px; height: 40px; background: #FFD700; border: 2px solid #ddd; border-radius: 6px; cursor: pointer;"></button>
                <button onclick="applyColor('#98FB98')" style="width: 40px; height: 40px; background: #98FB98; border: 2px solid #ddd; border-radius: 6px; cursor: pointer;"></button>
                <button onclick="applyColor('#87CEEB')" style="width: 40px; height: 40px; background: #87CEEB; border: 2px solid #ddd; border-radius: 6px; cursor: pointer;"></button>
                <button onclick="applyColor('#DDA0DD')" style="width: 40px; height: 40px; background: #DDA0DD; border: 2px solid #ddd; border-radius: 6px; cursor: pointer;"></button>
                <button onclick="applyColor('#FFF8DC')" style="width: 40px; height: 40px; background: #FFF8DC; border: 2px solid #ddd; border-radius: 6px; cursor: pointer;"></button>
                <button onclick="applyColor('#FF6B6B')" style="width: 40px; height: 40px; background: #FF6B6B; border: 2px solid #ddd; border-radius: 6px; cursor: pointer;"></button>
                <button onclick="applyColor('#4ECDC4')" style="width: 40px; height: 40px; background: #4ECDC4; border: 2px solid #ddd; border-radius: 6px; cursor: pointer;"></button>
                <button onclick="applyColor('#45B7D1')" style="width: 40px; height: 40px; background: #45B7D1; border: 2px solid #ddd; border-radius: 6px; cursor: pointer;"></button>
                <button onclick="applyColor('#96CEB4')" style="width: 40px; height: 40px; background: #96CEB4; border: 2px solid #ddd; border-radius: 6px; cursor: pointer;"></button>
                <button onclick="applyColor('#FFEAA7')" style="width: 40px; height: 40px; background: #FFEAA7; border: 2px solid #ddd; border-radius: 6px; cursor: pointer;"></button>
                <button onclick="applyColor('#DFE6E9')" style="width: 40px; height: 40px; background: #DFE6E9; border: 2px solid #ddd; border-radius: 6px; cursor: pointer;"></button>
            </div>
            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 20px;">
                <span>è‡ªå®šä¹‰:</span>
                <input type="color" id="custom-color" value="#FFE4E1" style="width: 50px; height: 40px; border: none; cursor: pointer;">
                <button onclick="applyCustomColor()" class="btn-secondary" style="padding: 8px 16px; font-size: 12px;">åº”ç”¨</button>
            </div>
            <button onclick="closeColorModal()" class="btn-secondary" style="width: 100%;">å–æ¶ˆ</button>
        </div>
    </div>

    <!-- ä½¿ç”¨è¯´æ˜ -->
    <div style="position: fixed; bottom: 20px; left: 20px; background: rgba(255,255,255,0.95); padding: 16px; border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); max-width: 320px; font-size: 13px; color: #4b5563; line-height: 1.6;">
        <strong style="color: #1f2937; display: block; margin-bottom: 8px;">ğŸ“– æ“ä½œæŒ‡å—</strong>
        <div style="display: grid; gap: 4px;">
            <div>â€¢ <strong>ç‚¹å‡»ç©ºç™½å¤„</strong>ï¼šåˆ›å»ºä¸€çº§å•ä½</div>
            <div>â€¢ <strong>ç‚¹å‡»æ–¹å—ç©ºç™½å¤„</strong>ï¼šæ·»åŠ ä¸‹çº§å•ä½</div>
            <div>â€¢ <strong>ç‚¹å‡»æ–‡å­—</strong>ï¼šç¼–è¾‘å†…å®¹</div>
            <div>â€¢ <strong>æ‹–æ‹½æ–¹å—</strong>ï¼šè°ƒæ•´ä½ç½®</div>
            <div>â€¢ <strong>å³é”®èœå•</strong>ï¼šæ”¹è‰²/è¿çº¿/åˆ é™¤/åŠ åŒçº§</div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('main-canvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('canvas-container');
        const contextMenu = document.getElementById('context-menu');
        const nodeInput = document.getElementById('node-input');
        const colorModal = document.getElementById('color-modal');
        const connectionStatus = document.getElementById('connection-status');
        const tooltip = document.getElementById('tooltip');

        let nodes = [];
        let connections = [];
        let scale = 1;
        let nextId = 1;
        let selectedNode = null;
        let editingNode = null;
        let connectingNode = null;
        let isConnectionMode = false;
        let dragNode = null;
        let dragOffsetX = 0;
        let dragOffsetY = 0;
        let isDragging = false;

        // è®¾ç½®ç”»å¸ƒå¤§å°
        function resizeCanvas() {
            canvas.width = Math.max(container.clientWidth, 1200);
            canvas.height = Math.max(container.clientHeight, 800);
            draw();
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // èŠ‚ç‚¹ç±»
        class Node {
            constructor(x, y, text = '', parent = null) {
                this.id = nextId++;
                this.x = x;
                this.y = y;
                this.text = text || `å•ä½${this.id}`;
                this.width = 140;
                this.height = 60;
                this.color = '#FFE4E1';
                this.parent = parent;
                this.level = parent ? parent.level + 1 : 1;
            }

            draw(ctx) {
                // é˜´å½±
                ctx.fillStyle = 'rgba(0,0,0,0.1)';
                ctx.fillRect(this.x - this.width/2 + 3, this.y - this.height/2 + 3, this.width, this.height);

                // ç»˜åˆ¶æ–¹å—
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x - this.width/2, this.y - this.height/2, this.width, this.height);

                // è¾¹æ¡†
                ctx.strokeStyle = dragNode === this ? '#764ba2' : '#333';
                ctx.lineWidth = dragNode === this ? 3 : 2;
                ctx.strokeRect(this.x - this.width/2, this.y - this.height/2, this.width, this.height);

                // æ–‡å­—åŒºåŸŸèƒŒæ™¯ï¼ˆä¸ŠåŠéƒ¨åˆ†ï¼‰
                ctx.fillStyle = 'rgba(255,255,255,0.3)';
                ctx.fillRect(this.x - this.width/2, this.y - this.height/2, this.width, this.height * 0.7);

                // æ–‡å­—
                ctx.fillStyle = '#333';
                ctx.font = 'bold 14px "Microsoft YaHei", sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                // æ–‡å­—æ¢è¡Œå¤„ç†
                const maxWidth = this.width - 10;
                const lineHeight = 18;
                const lines = this.getLines(ctx, this.text, maxWidth);
                const startY = this.y - (lines.length - 1) * lineHeight / 2;

                lines.forEach((line, index) => {
                    ctx.fillText(line, this.x, startY + index * lineHeight);
                });

                // å¦‚æœæ­£åœ¨è¿çº¿ï¼Œæ˜¾ç¤ºæ ‡è®°
                if (connectingNode === this) {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, 8, 0, Math.PI * 2);
                    ctx.fillStyle = '#764ba2';
                    ctx.fill();
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }

            getLines(ctx, text, maxWidth) {
                const chars = text.split('');
                const lines = [];
                let currentLine = '';

                for (let char of chars) {
                    const testLine = currentLine + char;
                    const metrics = ctx.measureText(testLine);
                    if (metrics.width > maxWidth && currentLine !== '') {
                        lines.push(currentLine);
                        currentLine = char;
                    } else {
                        currentLine = testLine;
                    }
                }
                lines.push(currentLine);
                return lines.length > 0 ? lines : [''];
            }

            contains(x, y) {
                return x >= this.x - this.width/2 && x <= this.x + this.width/2 &&
                       y >= this.y - this.height/2 && y <= this.y + this.height/2;
            }

            isTextArea(x, y) {
                // ä¸ŠåŠéƒ¨åˆ†ä¸ºæ–‡å­—åŒº
                return y >= this.y - this.height/2 && y <= this.y;
            }
        }

        // ç»˜åˆ¶è¿çº¿ï¼ˆè´å¡å°”æ›²çº¿ï¼‰
        function drawConnections() {
            connections.forEach(conn => {
                const fromNode = nodes.find(n => n.id === conn.from);
                const toNode = nodes.find(n => n.id === conn.to);
                if (!fromNode || !toNode) return;

                ctx.beginPath();
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 2;

                const startX = fromNode.x;
                const startY = fromNode.y + fromNode.height/2;
                const endX = toNode.x;
                const endY = toNode.y - toNode.height/2;

                const dist = Math.abs(endY - startY);
                const cp1x = startX;
                const cp1y = startY + dist * 0.5;
                const cp2x = endX;
                const cp2y = endY - dist * 0.5;

                ctx.moveTo(startX, startY);
                ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, endX, endY);
                ctx.stroke();

                // ç®­å¤´ï¼ˆå¯é€‰ï¼‰
                // ctx.beginPath();
                // ctx.moveTo(endX, endY);
                // ctx.lineTo(endX - 5, endY - 8);
                // ctx.lineTo(endX + 5, endY - 8);
                // ctx.fillStyle = '#666';
                // ctx.fill();
            });
        }

        // ä¸»ç»˜åˆ¶å‡½æ•°
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            ctx.save();
            ctx.scale(scale, scale);

            // ç»˜åˆ¶æ ‡é¢˜
            const title = document.getElementById('chart-title').value;
            if (title) {
                ctx.fillStyle = '#1f2937';
                ctx.font = 'bold 28px "Microsoft YaHei", sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(title, canvas.width/(2*scale), 50);

                // è£…é¥°çº¿
                ctx.strokeStyle = '#764ba2';
                ctx.lineWidth = 3;
                ctx.beginPath();
                const textWidth = ctx.measureText(title).width;
                ctx.moveTo(canvas.width/(2*scale) - textWidth/2, 65);
                ctx.lineTo(canvas.width/(2*scale) + textWidth/2, 65);
                ctx.stroke();
            }

            // ç»˜åˆ¶è¿çº¿
            drawConnections();

            // ç»˜åˆ¶èŠ‚ç‚¹ï¼ˆæŒ‰å±‚çº§æ’åºï¼Œå…ˆç”»åº•å±‚çš„ï¼‰
            const sortedNodes = [...nodes].sort((a, b) => a.level - b.level);
            sortedNodes.forEach(node => node.draw(ctx));

            ctx.restore();
        }

        // åæ ‡è½¬æ¢
        function getMousePos(evt) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: (evt.clientX - rect.left) / scale,
                y: (evt.clientY - rect.top) / scale
            };
        }

        // é¼ æ ‡æŒ‰ä¸‹
        canvas.addEventListener('mousedown', function(e) {
            if (e.button !== 0) return;

            const pos = getMousePos(e);
            const clickedNode = nodes.find(n => n.contains(pos.x, pos.y));

            if (clickedNode && !isConnectionMode) {
                dragNode = clickedNode;
                dragOffsetX = pos.x - clickedNode.x;
                dragOffsetY = pos.y - clickedNode.y;
                isDragging = false;
            }
        });

        // é¼ æ ‡ç§»åŠ¨
        canvas.addEventListener('mousemove', function(e) {
            const pos = getMousePos(e);

            if (dragNode) {
                isDragging = true;
                dragNode.x = pos.x - dragOffsetX;
                dragNode.y = pos.y - dragOffsetY;
                draw();
            } else {
                // æ£€æŸ¥ hover
                const hoveredNode = nodes.find(n => n.contains(pos.x, pos.y));
                if (hoveredNode) {
                    canvas.style.cursor = 'move';
                    tooltip.style.display = 'block';
                    tooltip.style.left = (e.clientX + 10) + 'px';
                    tooltip.style.top = (e.clientY + 10) + 'px';
                } else {
                    canvas.style.cursor = isConnectionMode ? 'pointer' : 'crosshair';
                    tooltip.style.display = 'none';
                }
            }
        });

        // é¼ æ ‡æ¾å¼€
        canvas.addEventListener('mouseup', function(e) {
            if (e.button !== 0) return;

            const pos = getMousePos(e);

            if (dragNode) {
                if (!isDragging) {
                    // ç‚¹å‡»ï¼ˆéæ‹–æ‹½ï¼‰
                    handleNodeClick(dragNode, pos);
                }
                dragNode = null;
            } else {
                // ç‚¹å‡»ç©ºç™½å¤„
                if (!isConnectionMode) {
                    addRootNode(pos.x, pos.y);
                } else {
                    // è¿çº¿æ¨¡å¼ç‚¹å‡»ç©ºç™½ï¼Œå–æ¶ˆ
                    exitConnectionMode();
                }
            }

            isDragging = false;
            draw();
        });

        // å¤„ç†èŠ‚ç‚¹ç‚¹å‡»
        function handleNodeClick(node, pos) {
            if (isConnectionMode) {
                if (!connectingNode) {
                    connectingNode = node;
                    connectionStatus.textContent = `ä» "${connectingNode.text}" è¿çº¿åˆ°...`;
                } else if (connectingNode.id !== node.id) {
                    const exists = connections.some(c => 
                        (c.from === connectingNode.id && c.to === node.id) ||
                        (c.from === node.id && c.to === connectingNode.id)
                    );
                    if (!exists) {
                        connections.push({from: connectingNode.id, to: node.id});
                    }
                    exitConnectionMode();
                }
            } else {
                if (node.isTextArea(pos.x, pos.y)) {
                    editNodeText(node);
                } else {
                    addChildNode(node);
                }
            }
        }

        // æ·»åŠ æ ¹èŠ‚ç‚¹
        function addRootNode(x, y) {
            const node = new Node(x, y, prompt('è¯·è¾“å…¥ä¸€çº§å•ä½åç§°ï¼š', 'è¡Œæ”¿é•¿å®˜'));
            if (node.text) {
                node.color = '#FFE4E1'; // é»˜è®¤ç²‰è‰²ï¼ˆæœ€é«˜å±‚ï¼‰
                nodes.push(node);
                draw();
            }
        }

        // æ·»åŠ å­èŠ‚ç‚¹
        function addChildNode(parent) {
            const text = prompt('è¯·è¾“å…¥ä¸‹çº§å•ä½åç§°ï¼š', 'æ–°å•ä½');
            if (!text) return;

            // è‡ªåŠ¨å¸ƒå±€ï¼šæ‰¾åˆ°è¯¥çˆ¶èŠ‚ç‚¹ä¸‹æ–¹çš„ç©ºä½
            const siblings = nodes.filter(n => n.parent && n.parent.id === parent.id);
            const index = siblings.length;

            // è®¡ç®—åˆé€‚çš„é—´è·
            const spacing = 180;
            const totalWidth = (siblings.length + 1) * spacing;
            const startX = parent.x - totalWidth/2 + spacing/2;

            const x = startX + (index * spacing);
            const y = parent.y + 140;

            const node = new Node(x, y, text, parent);

            // æ ¹æ®å±‚çº§ç»™é»˜è®¤é¢œè‰²
            const colors = ['#FFE4E1', '#FFD700', '#98FB98', '#87CEEB', '#DDA0DD'];
            node.color = colors[Math.min(node.level - 1, colors.length - 1)];

            nodes.push(node);
            connections.push({from: parent.id, to: node.id});
            draw();
        }

        // æ·»åŠ åŒçº§èŠ‚ç‚¹
        function addSiblingNode() {
            if (!selectedNode || !selectedNode.parent) {
                alert('åªèƒ½ä¸ºå·²æœ‰çˆ¶èŠ‚ç‚¹çš„å•ä½æ·»åŠ åŒçº§å•ä½');
                return;
            }

            const parent = selectedNode.parent;
            const text = prompt('è¯·è¾“å…¥åŒçº§å•ä½åç§°ï¼š', 'æ–°å•ä½');
            if (!text) return;

            const siblings = nodes.filter(n => n.parent && n.parent.id === parent.id);
            const index = siblings.length;
            const spacing = 180;
            const x = parent.x + (index - siblings.length/2) * spacing;
            const y = parent.y + 140;

            const node = new Node(x, y, text, parent);
            node.color = selectedNode.color;
            nodes.push(node);
            connections.push({from: parent.id, to: node.id});
            draw();
            contextMenu.style.display = 'none';
        }

        // ç¼–è¾‘èŠ‚ç‚¹æ–‡å­—
        function editNodeText(node) {
            editingNode = node;
            const rect = canvas.getBoundingClientRect();

            nodeInput.value = node.text;
            nodeInput.style.display = 'block';
            nodeInput.style.left = (rect.left + (node.x - node.width/2) * scale) + 'px';
            nodeInput.style.top = (rect.top + (node.y - 20) * scale) + 'px';
            nodeInput.style.width = (node.width * scale) + 'px';
            nodeInput.style.fontSize = (14 * scale) + 'px';
            nodeInput.focus();
            nodeInput.select();
        }

        nodeInput.addEventListener('blur', function() {
            if (editingNode) {
                editingNode.text = this.value || 'æœªå‘½å';
                editingNode = null;
                this.style.display = 'none';
                draw();
            }
        });

        nodeInput.addEventListener('keydown', function(e) {
            if (e.key === 'Enter') this.blur();
        });

        // å³é”®èœå•
        canvas.addEventListener('contextmenu', function(e) {
            e.preventDefault();
            const pos = getMousePos(e);
            const clickedNode = nodes.find(n => n.contains(pos.x, pos.y));

            if (clickedNode && !isConnectionMode) {
                selectedNode = clickedNode;
                contextMenu.style.display = 'block';
                contextMenu.style.left = Math.min(e.clientX, window.innerWidth - 160) + 'px';
                contextMenu.style.top = Math.min(e.clientY, window.innerHeight - 200) + 'px';
            } else {
                contextMenu.style.display = 'none';
            }
        });

        document.addEventListener('click', function(e) {
            if (!contextMenu.contains(e.target)) {
                contextMenu.style.display = 'none';
            }
        });

        // èœå•åŠŸèƒ½
        function startEditText() {
            if (selectedNode) editNodeText(selectedNode);
            contextMenu.style.display = 'none';
        }

        function changeColor() {
            colorModal.style.display = 'flex';
            contextMenu.style.display = 'none';
        }

        function applyColor(color) {
            if (selectedNode) {
                selectedNode.color = color;
                draw();
            }
            closeColorModal();
        }

        function applyCustomColor() {
            applyColor(document.getElementById('custom-color').value);
        }

        function closeColorModal() {
            colorModal.style.display = 'none';
            selectedNode = null;
        }

        function startConnection() {
            isConnectionMode = true;
            connectingNode = null;
            connectionStatus.style.display = 'inline-flex';
            connectionStatus.textContent = 'è¿çº¿æ¨¡å¼ï¼šé€‰æ‹©èµ·å§‹å•ä½';
            contextMenu.style.display = 'none';
            canvas.style.cursor = 'pointer';
        }

        function exitConnectionMode() {
            isConnectionMode = false;
            connectingNode = null;
            connectionStatus.style.display = 'none';
            canvas.style.cursor = 'crosshair';
            draw();
        }

        function deleteNode() {
            if (selectedNode) {
                if (!confirm(`ç¡®å®šåˆ é™¤ "${selectedNode.text}" å—ï¼Ÿå…¶ä¸‹çº§å•ä½å°†å˜ä¸ºè‡ªç”±èŠ‚ç‚¹ã€‚`)) return;

                connections = connections.filter(c => 
                    c.from !== selectedNode.id && c.to !== selectedNode.id
                );

                // æ–­å¼€çˆ¶å­å…³ç³»ï¼Œå­èŠ‚ç‚¹å˜ä¸ºæ ¹èŠ‚ç‚¹
                nodes.forEach(n => {
                    if (n.parent && n.parent.id === selectedNode.id) {
                        n.parent = null;
                        n.level = 1;
                    }
                });

                nodes = nodes.filter(n => n.id !== selectedNode.id);
                draw();
            }
            contextMenu.style.display = 'none';
        }

        // è‡ªåŠ¨å¸ƒå±€ï¼ˆæ ‘å½¢æ’åˆ—ï¼‰
        function autoLayout() {
            if (nodes.length === 0) return;

            // æ‰¾åˆ°æ‰€æœ‰æ ¹èŠ‚ç‚¹
            const roots = nodes.filter(n => !n.parent);
            if (roots.length === 0) {
                // å¦‚æœæ²¡æœ‰æ ¹èŠ‚ç‚¹ï¼Œè®¾ç¬¬ä¸€ä¸ªä¸ºæ ¹
                nodes[0].level = 1;
                roots.push(nodes[0]);
            }

            const levelHeight = 140;
            const nodeWidth = 180;

            function layoutNode(node, x, y) {
                node.x = x;
                node.y = y;

                const children = nodes.filter(n => n.parent && n.parent.id === node.id);
                if (children.length > 0) {
                    const totalWidth = children.length * nodeWidth;
                    const startX = x - totalWidth/2 + nodeWidth/2;

                    children.forEach((child, index) => {
                        layoutNode(child, startX + index * nodeWidth, y + levelHeight);
                    });
                }
            }

            // è®¡ç®—æ•´ä½“åç§»ä½¿å›¾è¡¨å±…ä¸­
            const rootX = canvas.width / (2 * scale);
            const rootY = 100;

            // å¸ƒå±€æ¯ä¸ªæ ¹èŠ‚ç‚¹ï¼ˆå¹¶è¡Œæ”¿æƒï¼‰
            const rootSpacing = 400;
            const totalRootsWidth = roots.length * rootSpacing;
            const startRootX = rootX - totalRootsWidth/2 + rootSpacing/2;

            roots.forEach((root, index) => {
                layoutNode(root, startRootX + index * rootSpacing, rootY);
                updateLevels(root, 1);
            });

            draw();
        }

        function updateLevels(node, level) {
            node.level = level;
            const children = nodes.filter(n => n.parent && n.parent.id === node.id);
            children.forEach(child => updateLevels(child, level + 1));
        }

        // ç¼©æ”¾æ§åˆ¶
        const scaleSlider = document.getElementById('scale-slider');
        const scaleValue = document.getElementById('scale-value');

        scaleSlider.addEventListener('input', function() {
            scale = parseFloat(this.value);
            scaleValue.textContent = Math.round(scale * 100) + '%';
            draw();
        });

        // ä¸‹è½½PNG
        function downloadPNG() {
            if (nodes.length === 0) {
                alert('ç”»å¸ƒä¸ºç©ºï¼Œè¯·å…ˆåˆ›å»ºç»“æ„å›¾');
                return;
            }

            // è®¡ç®—è¾¹ç•Œ
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            nodes.forEach(n => {
                minX = Math.min(minX, n.x - n.width/2);
                minY = Math.min(minY, n.y - n.height/2);
                maxX = Math.max(maxX, n.x + n.width/2);
                maxY = Math.max(maxY, n.y + n.height/2);
            });

            const padding = 60;
            const width = maxX - minX + padding * 2;
            const height = maxY - minY + padding * 2 + (document.getElementById('chart-title').value ? 80 : 0);

            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = width;
            tempCanvas.height = height;
            const tempCtx = tempCanvas.getContext('2d');

            // ç™½è‰²èƒŒæ™¯
            tempCtx.fillStyle = 'white';
            tempCtx.fillRect(0, 0, width, height);

            tempCtx.save();
            tempCtx.translate(-minX + padding, -minY + padding + (document.getElementById('chart-title').value ? 60 : 0));

            // æ ‡é¢˜
            const title = document.getElementById('chart-title').value;
            if (title) {
                tempCtx.fillStyle = '#1f2937';
                tempCtx.font = 'bold 28px "Microsoft YaHei", sans-serif';
                tempCtx.textAlign = 'center';
                tempCtx.fillText(title, (minX + maxX)/2, minY - 30);
            }

            // è¿çº¿å’ŒèŠ‚ç‚¹
            connections.forEach(conn => {
                const fromNode = nodes.find(n => n.id === conn.from);
                const toNode = nodes.find(n => n.id === conn.to);
                if (!fromNode || !toNode) return;

                tempCtx.beginPath();
                tempCtx.strokeStyle = '#666';
                tempCtx.lineWidth = 2;
                const dist = Math.abs(toNode.y - fromNode.y);
                tempCtx.moveTo(fromNode.x, fromNode.y + fromNode.height/2);
                tempCtx.bezierCurveTo(
                    fromNode.x, fromNode.y + fromNode.height/2 + dist * 0.5,
                    toNode.x, toNode.y - toNode.height/2 - dist * 0.5,
                    toNode.x, toNode.y - toNode.height/2
                );
                tempCtx.stroke();
            });

            nodes.forEach(node => {
                tempCtx.fillStyle = 'rgba(0,0,0,0.1)';
                tempCtx.fillRect(node.x - node.width/2 + 3, node.y - node.height/2 + 3, node.width, node.height);
                tempCtx.fillStyle = node.color;
                tempCtx.fillRect(node.x - node.width/2, node.y - node.height/2, node.width, node.height);
                tempCtx.strokeStyle = '#333';
                tempCtx.lineWidth = 2;
                tempCtx.strokeRect(node.x - node.width/2, node.y - node.height/2, node.width, node.height);
                tempCtx.fillStyle = '#333';
                tempCtx.font = 'bold 14px "Microsoft YaHei", sans-serif';
                tempCtx.textAlign = 'center';
                tempCtx.textBaseline = 'middle';
                tempCtx.fillText(node.text, node.x, node.y);
            });

            tempCtx.restore();

            const link = document.createElement('a');
            link.download = `æ”¿åºœç»“æ„å›¾-${new Date().toISOString().slice(0,10)}.png`;
            link.href = tempCanvas.toDataURL();
            link.click();
        }

        function clearCanvas() {
            if (confirm('ç¡®å®šæ¸…ç©ºæ‰€æœ‰å†…å®¹å—ï¼Ÿ')) {
                nodes = [];
                connections = [];
                nextId = 1;
                draw();
            }
        }

        // åˆå§‹åŒ–ç¤ºä¾‹
        function initExample() {
            document.getElementById('chart-title').value = 'é¦™æ¸¯ç‰¹åˆ«è¡Œæ”¿åŒºæ”¿åºœç»„ç»‡æ¶æ„å›¾ï¼ˆç¤ºä¾‹ï¼‰';

            // åˆ›å»ºä¸‰å¸ç»“æ„
            const root = new Node(canvas.width/(2*scale), 100, 'è¡Œæ”¿é•¿å®˜');
            root.color = '#FFE4E1';
            nodes.push(root);

            const cs = new Node(root.x - 250, 250, 'æ”¿åŠ¡å¸å¸é•¿');
            cs.color = '#FFD700';
            cs.parent = root;
            nodes.push(cs);
            connections.push({from: root.id, to: cs.id});

            const fs = new Node(root.x, 250, 'è´¢æ”¿å¸å¸é•¿');
            fs.color = '#FFD700';
            fs.parent = root;
            nodes.push(fs);
            connections.push({from: root.id, to: fs.id});

            const js = new Node(root.x + 250, 250, 'å¾‹æ”¿å¸å¸é•¿');
            js.color = '#FFD700';
            js.parent = root;
            nodes.push(js);
            connections.push({from: root.id, to: js.id});

            // ä¸‹å±å±€ç¤ºä¾‹
            const edu = new Node(cs.x - 80, 380, 'æ•™è‚²å±€');
            edu.color = '#98FB98';
            edu.parent = cs;
            nodes.push(edu);
            connections.push({from: cs.id, to: edu.id});

            const env = new Node(cs.x + 80, 380, 'ç¯å¢ƒå±€');
            env.color = '#98FB98';
            env.parent = cs;
            nodes.push(env);
            connections.push({from: cs.id, to: env.id});

            draw();
        }

        window.onload = initExample;
    </script>
</body>
</html>
